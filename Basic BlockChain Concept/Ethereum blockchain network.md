# 이더리움

## 이더리움이란?
- 분산 애플리케이션을 생성 및 배포하는 오픈소스 플랫폼



## 이더리움 네트워크의 특징
- 누구나 무료로 계정을 생성하고 솔루션과 스마트 계약을 배포할 수 있음
- 네트워크를 사용하는 데 가스가 들음
- 인터넷 상의 공중 체인으로서 누구나 접속해서 이더리움 네트워크에 저장된 데이터와 거래에 접근 가능



## 테스트 네트워크
- 이더리움 블록체인의 구축 및 도입을 도와주는 테스트 네트워크
- 이더리움 메인 네트워크를 완벽히 복제한 것으로 계약을 배포 및 사용하는데 비용 X
- Ropsten, Kovan, Rinkeby 등의 테스트 네트워크 존재
    - Ropsten : 작업 증명 사용
    - Kovan, Rinkeby : 권한 증명(Proof of Authority)



## 이더리움 vs 비트코인

### 비트 코인이 가지는 한계점
1. Turing-incompleteness (튜링 불완전성)
	아주 단순하고 표현방법이 많지 않은 언어

2. Lack of State (상태 표현 제한)
	비트코인의 UTXO(비트코인의 잔액덩어리)를 표현하는 상태 : 사용했거나 안했거나
	전부 사용이 아닌 나눠서 사용할 수 없음

3. Blockchain-blindness
	화폐의 기능 이외의 다른 분야의 어플리케이션을 만드는데 한계가 있음
	애초에 비트코인은 돈거래를 기록하기 위해 설계된 블록체인임
	<br> >> 거래 정보 이외에 다른 정보를 기록하는 것이 어렵고, 거래 안에 담을 수 있는 코드도 매우 한정적

### 비트코인과 이더리움의 차이
- 비트코인이 단순히 화폐 기능만 수행한다면 이더리움은 여러 어플리케이션(금융, 신원관리, SNS, 의료, 예술, 정부행정, 보험 등)을 실행하려 함



## 이더리움의 역사와 로드맵
- 4단계 업데이트로 플랫폼을 완성한다는 계획

1. 프런티어(Frontier)
    - 2015년 7월 30일 실시
    - 명령 줄 인터페이스 기반 탈중앙화 어플리케이션 개발의 기초 테스트
    - 이더리움을 개발 및 채굴하고 네트워크를 형성하는 단계

2. 홈스테드(Homestead)
    - 2016년 3월 14일 실시
    - 노드가 생기면서 생태계를 구축하는 단계
    - 거래의 고속화 및 안정화도 추구

3. 메트로폴리스(Metropolis)
    - 2017년 10월 17일 실시하여 아직 진행 중
    - 대중화를 위한 인프라가 형성되는 시기
    - 1단계, 하드 포크 비잔티움(Byzantium)
        - 437만번째 블록을 기준으로 제로 지식 증명 zk-SNARK, 블록 생성 시간 안정화, 예외 처리로 가스 반환 등을 도입
    - 2단계, 하드 포크 콘스탄티노플(Constantinople)
        - 2019년 3월에 708만번째 블록을 기준으로 실시
        - 이더리움 채굴을 작업 증명(PoW)과 지분 증명(PoS)을 혼합해 사용하는 방식으로 전환하기 위한 대비, EVM 성능 향상 등을 업데이트
        - [참고1][1] [참고2][2]

4. 세레니티(Serenity)
    - 진행일 미정
    - 지분 증명 알고리즘(PoS)의 안정화를 위한 마지막 단계



## EVM(Ethereum Virtual Machine)
- 이더리움 가상 머신
- 스마트 컨트랙트의 터전
- 모든 트랜잭션 전송이나 컨트랙트의 실행은 EVM에서 이루어짐



## Smart Contract
- 온라인 상에서 특정 계약조건을 이행하는 것
- 이더리움 플랫폼에서 정해 놓은 '헌법'과도 같음
- 블록체인 위에 약속을 올려놓는 것



## 이더리움 노드
- 노드는 P2P 프로토콜을 통해 연결되어 이더리움 네트워크를 형성하는 컴퓨터들을 말함

### 이더리움에 존재하는 두 종류의 노드
- 채굴하지 않고 EVM 역할만 담당하는 노드가 존재하는 경우는 많지 않음
- EVM 노드를 포함한 모든 노드가 채굴자로서 행동하는 것이 일반적
    1. EVM
        - 이더리움 네트워크 노드들이 공유하는 하나의 가상 머신
        - 다수의 사용자들에 의해 동시에 데이터가 변경되지 않도록 충돌을 중재
        - EVM은 누구나 사용가능하기 때문에 무한루프나 고도의 연산량을 필요로 하는 비효율적인 코드를 새로 생성시킨다면 이더리움 가상머신에 매우 큰 부하가 발생할 것임. 이를 예방하기 위해 작업 용량만큼 Gas를 지불하도록 함
        - 이더리움 블록체인 네트워크의 노드들이 공유하는 하나의 가상머신, 분산 컴퓨터
        - ERC20 토큰들이 만들어지고 동작하는 장소
        - 이더리움 네트워크의 실행 런타임
        - 스마트 컨트랙트에 쓰여진 코드를 실행하는 런타임을 제공하는 것
    2. 채굴 노드
        - 채굴자에게 속한 노드
        - 이더리움 체인에 거래를 기록할 책임이 있음



## 채굴자가 얻는 보상 두가지
- 체인에 블록을 기록하는 보상
- 블록의 모든 거래로부터 누적된 가스료를 얻음



## 채굴은 어떻게 이루어지는가?
- 채굴자는 항상 새로운 블록을 채굴하고자 함
- 다른 채굴자가 생성한 새로운 블록을 능동적으로 리스닝
- 거래 풀에 저장할 새로운 거래도 리스닝



## EVM 설계적 한계
1. 실행코드(Opcode) 기반의 가스 수수료 부과 시스템
2. 경쟁방식의 검증인 블록 생성과 이기적 검증인 >> 수수료가 비싼 것부터 처리
3. 공격자를 막기 위해서는 수수료를 비싸게, 사용자를 위해서는 수수료를 싸게 해야하므로 비용적인 측면에서 딜레마가 존재



## 이더리움 상의 계좌
- 참고 : [쉽게 설명하는 블록체인][3]
1. 외부 소유 계좌(EOA)
    - 개인키를 가지고 통제
	- 이더를 주고 받을 수 있는 일반적인 은행 계좌와 비슷

2. 계약 계좌(Contract Account)
	- 개인키가 아닌 계약 코드에 의해서 통제
	- '계약 코드'와 '계약에 필요한 정보들을 저장하는 공간'을 가지고 있으며 내부 저장공간의 데이터를 읽고 쓸 수 있음



### 이더리움을 실제 서비스에 적용하는데 마주한 어려움
- 참고 : https://brunch.co.kr/@bumgeunsong/47#comment
1. 확장가능성 문제(Scalability)
	- 이더리움의 느린 거래 처리 속도
	- 13 tps(transaction per second)
	<br> >> 복잡한 프로그램을 돌리기보다 간단한 조건문이나 인증 절차 등의 단순한 태스크에 적합	

	cf. 페이스북의 요청 처리 속도
		1초에 약 17만 5천개의 요청 처리(사용자들이 직접 보내는 요청 기준)
	
	- 확장성 문제 해결을 위한 스케일링 솔루션
	    - On-Chain
		    - 블록체인에 거래가 기록되는 속도를 높임
		    (이 방식을 채택한다고 해도 10배 이상 속도를 높이기 어려움)

	    - Off-Chain
		    - 거래 처리는 블록체인 외부에서 하고 최종적인 결과만 블록체인에 기록하는 방식
		    - 이더리움 커뮤니티에서 Off-Chain 솔루션 개발에 촉각을 곤두세우고 있음 
		    (이더리움의 확장가능성 문제를 해결하기 위해선 이 방식을 이용한 해결책이 나와야 함)

 2. 합의 메커니즘(Consensus Mechanism)
	- PoW 방식의 합의 메커니즘을 사용
	<br> >> 많은 에너지 소모, 특정 채굴 회사에 쏠림 현상 발생
	- 이더리움은 다음 업데이트에서 PoS(Proof-of-stake) 방식으로 전환 준비 중
		
	cf. PoS
		- 참가자들이 블록에 대해서 베팅을 하는 방식
		- 베팅한 금액이 높을 수록 블록 생성 권한을 받을 확률이 높아짐
		- 참가자들은 문제가 없다고 생각하는 곳에 이더를 건다
		<br> >> 블록이 체인에 잘 연결되고 문제가 없음이 판명나면, 블록을 생성한 참가자는 보상을 받음
		<br> >> 문제가 있으면 베팅금 날림
		- 전체 베팅 금액의 몇 %를 소유했느냐에 따라 권력이 주어짐
		    - 장점) 비싼 채굴 장비, 막대한 양의 전기가 필요 없음. 거래 처리 속도 향상, 악의적인 행위를 했을 때 PoW과 달리 큰 페널티가 주어짐
		    - 단점) 빈익빈 부익부 현상이 발생

 3. 프라이버시(Privacy)
	- 블록체인 위에서 다양한 비지니스가 일어나는데 이 정보들이 모두 투명하게 공개됨
	<br> >> 다음 업데이트에서 거래 내역을 모두 암호화할 수 있는 zk-SHARK 알고리즘을 도입할 예정

 4. 스마트 컨트랙트의 불완전성
	- 수많은 활용 가능성을 열어둔 만큼 이더리움의 높은 자유도는 다양한 버그와 보안상 허점을 만들어냄
	ex) 2016 'The DAO 프로젝트' 해킹 사건 : 스마트 컨트랙트 코드의 약점을 찾아 펀딩 금액의 1/3을 잃은 해킹 사건

 5. 지나치게 엄격한 계약
	- 블록체인에서 일어난 거래는 어떤 일이 있든 되돌릴 수 없음
	- 융통성이 없는 고지식함으로 인해 문제가 발생할 여지가 큼
	
 6. 내부 거버넌스(On-Chain Goverance)의 부재
	- 아무도 이더리움 프로토콜에 대한 결정권이나 책임이 없기에 자체적으로 프로토콜을 업데이트할 방법이 없음
	(90% 동의를 받아야 프로토콜 업데이트가 가능)
	- 프로토콜 업그레이드를 하려면 거의 모든 참여자들의 동의를 받아야 함
	<br> >> 반대자들은 하드 포크로 떨어져 나감
	


## 이더리움 Tools

### 가나슈(Ganache)
- 이더리움에서 원장에 거래를 기록하는 작업은 시간이 많이 소요되므로 개발과 테스트 단계에서 문제가 됨.
- 자체적으로 이더리움 거래 처리와 채굴 기능을 갖고 있어 거래 채굴 대기 시간이 없음. 거래는 생성되는 대로 기록됨.
- 이더리움 솔루션 및 스마트 계약의 개발과 테스트 과정을 간소화하기 위해 개발된 프로그램



## 솔리디티(Solidity)
- 스마트 계약을 작성하는 데 사용하는 언어 중 하나
솔리디티 코드를 솔리디티 컴파일러를 사용해 컴파일하면 바이트 코드와 함께 배포에 필요한 것들이 출력됨
이더리움 가상 머신을 대상으로 하는 프로그래밍 언어



## Web3 자바스크립트 라이브러리
- 같은 컴퓨터 또는 다른 컴퓨터로부터 이더리움 노드에 접속하는 데 사용할 수 있는 오픈소스 자바스크립트 라이브러리
- RPC뿐만 아니라 IPC로도 이더리움 노드에 연결 가능
클라이언트 측 라이브러리
- 웹 페이지 및 질의에서 사용될 수 있고 이더리움 노드에 거래를 제출할 수 있음
- JSON-RPC를 호출해주는 라이브러리로 개발자가 좀 더 쉽게 응용 서비스나 Dapp을 구현할 수 있도록 도움.
- 공식 문서 : https://web3js.readthedocs.io/en/1.0/web3.html



## 미스트 지갑
- 이더를 주고 받기 위해 지갑 역할을 함
- 계정 생성, 이더 송수신, 계약 배포 및 호출 가능



## 메타마스크
- 이더리움 네트워크와의 상호작용을 돕는 경량의 크롬 브라우저 확장 프로그램
- 이더를 주고 받는 것을 돕는 지갑
- 전체 체인 데이터를 로컬에 다운로드 X
- 체인데이터는 중앙에 저장하고 사용자가 브라우저를 통해 그것을 연결하도록 도움



## 게스
- Go 언어로 구현된 이더리움 클라이언트
- 공중 및 테스트 네트워크에 연결
- EVM을 사용해 사설 네트워크를 위한 채굴 및 EVM(거래) 노드를 생성할 수 있음
- 사설 체인에서 노드와 채굴자를 생성할 수 있는 명령행 도구
- JSON 형식으로 인코딩된 페이로드를 가지고 원격 프로시저 호출의 명세를 정의 >>RPC 프로토콜에 기초



## JSON RPC와의 연결을 위해 게스가 사용하는 프로토콜
1. 프로세스 간 통신(IPC) : 같은 컴퓨터 내의 프로세스끼리 통신하는 데 사용되는 프로토콜
2. 원격 프로시저 호출(RPC) : 서로 다른 컴퓨터 사이의 프로세스 간 통신에 사용되는 프로토콜. TCP와 HTTP 프로토콜에 기초
3. 웹 소켓(WS) : 소켓을 통해 게스에 연결하는 데 사용되는 프로토콜

cf. 페이로드(Payload)
- payload : pay 지급한다. load 적화물에 대해서만
- 한마디로 내가 사용하기 위해 관심있는 데이터를 의미
- 사용에 있어서 전송되는 데이터
- 전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외
- 프로그래밍에서 주로 메시지 프로토콜 중에 프로토콜 오버헤드와 원하는 데이터를 구별할 때 사용
- 출처 : https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EB%A1%9C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)

cf. JSON이란
- Javascript Object Notation
- 파일 형식 이름
- name-value형태의 쌍으로 이루어짐
- 네트워크를 통해 데이터를 주고받는 데 사용되는 경량의 데이터 교환 형식
- 사람, 기계가 읽고 쓰고 분석하고 생성하는데 용이함

cf. RPC란
- Remote Procedure Call
- 멀리 떨어져(Remote) 있는 컴퓨터상의 프로그램이 다른 컴퓨터 내에 있는 서브프로그램(Procedure)을 불러내는(Call) 것을 의미

cf. JSON RPC란
- JSON을 데이터 포맷으로 사용하여 다른 원격 응용 프로그램과 통신할 수 있도록 한 API
- 원격 응용 프로그램과 통신하기에 적합한 인터페이스

cf. API
- Application Promgramming Interface
- 다른 응용프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
- 한 프로그램의 기능을 다른 프로그램이 쉽게 사용할 수 있도록 프로그램 간의 커뮤니케이션을 도와주는 것

cf. ABI
- Application Binary Interface
- 응용프로그램과 운영체제, 또는 응용 프로그램과 해당 라이브러리, 혹은 응용프로그램의 구성요소 간에서 사용되는 낮은 수준의 인터페이스
- API가 소스 코드에서 사용된다면 ABI는 바이너리에서 호환 가능하다는 점이 다름
- ABI는 바이너리 코드이기에 언어나 플랫폼에 독립적으로 해당 interface에 대한 정보를 제공할 수 있음
- 이더리움에서 바이너리 실행 파일과 Contract 내 설정한 함수/변수 등을 연결하는데 사용



[1]:https://medium.com/day34/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%BD%98%EC%8A%A4%ED%83%84%ED%8B%B0%EB%85%B8%ED%94%8C-%ED%95%98%EB%93%9C%ED%8F%AC%ED%81%AC-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-ethereum-constantinople-hardfork-d7dce501ba37

[2]:http://www.thebchain.co.kr/news/articleView.html?idxno=3505

[3]:https://banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%B4%EB%9E%80-3mqco
